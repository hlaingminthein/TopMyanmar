{"ast":null,"code":"const SMTPError = require('./error');\n/**\n * @typedef {import('net').Socket} Socket\n * @typedef {import('tls').TLSSocket} TLSSocket\n */\n\n\nclass SMTPResponse {\n  /**\n   * @constructor\n   * @param {Socket | TLSSocket} stream the open socket to stream a response from\n   * @param {number} timeout the time to wait (in milliseconds) before closing the socket\n   * @param {function(Error): void} onerror the function to call on error\n   */\n  constructor(stream, timeout, onerror) {\n    let buffer = '';\n    /**\n     * @returns {void}\n     */\n\n    const notify = () => {\n      if (buffer.length) {\n        // parse buffer for response codes\n        const line = buffer.replace('\\r', '');\n\n        if (!line.trim().split(/\\n/).pop().match(/^(\\d{3})\\s/)) {\n          return;\n        }\n\n        const match = line ? line.match(/(\\d+)\\s?(.*)/) : null;\n        const data = match !== null ? {\n          code: match[1],\n          message: match[2],\n          data: line\n        } : {\n          code: -1,\n          data: line\n        };\n        stream.emit('response', null, data);\n        buffer = '';\n      }\n    };\n    /**\n     * @param {Error} err the error object\n     * @returns {void}\n     */\n\n\n    const error = err => {\n      stream.emit('response', SMTPError('connection encountered an error', SMTPError.ERROR, err));\n    };\n    /**\n     * @param {Error} err the error object\n     * @returns {void}\n     */\n\n\n    const timedout = err => {\n      stream.end();\n      stream.emit('response', SMTPError('timedout while connecting to smtp server', SMTPError.TIMEDOUT, err));\n    };\n    /**\n     * @param {string | Buffer} data the data\n     * @returns {void}\n     */\n\n\n    const watch = data => {\n      if (data !== null) {\n        buffer += data.toString();\n        notify();\n      }\n    };\n    /**\n     * @param {Error} err the error object\n     * @returns {void}\n     */\n\n\n    const close = err => {\n      stream.emit('response', SMTPError('connection has closed', SMTPError.CONNECTIONCLOSED, err));\n    };\n    /**\n     * @param {Error} err the error object\n     * @returns {void}\n     */\n\n\n    const end = err => {\n      stream.emit('response', SMTPError('connection has ended', SMTPError.CONNECTIONENDED, err));\n    };\n    /**\n     * @param {Error} [err] the error object\n     * @returns {void}\n     */\n\n\n    this.stop = err => {\n      stream.removeAllListeners('response');\n      stream.removeListener('data', watch);\n      stream.removeListener('end', end);\n      stream.removeListener('close', close);\n      stream.removeListener('error', error);\n\n      if (err != null && typeof onerror === 'function') {\n        onerror(err);\n      }\n    };\n\n    stream.on('data', watch);\n    stream.on('end', end);\n    stream.on('close', close);\n    stream.on('error', error);\n    stream.setTimeout(timeout, timedout);\n  }\n\n}\n\nexports.SMTPResponse = SMTPResponse;\n/**\n * @param {Socket | TLSSocket} stream the open socket to stream a response from\n * @param {number} timeout the time to wait (in milliseconds) before closing the socket\n * @param {function(Error): void} onerror the function to call on error\n * @returns {SMTPResponse} the smtp response\n */\n\nexports.monitor = (stream, timeout, onerror) => new SMTPResponse(stream, timeout, onerror);","map":null,"metadata":{},"sourceType":"script"}