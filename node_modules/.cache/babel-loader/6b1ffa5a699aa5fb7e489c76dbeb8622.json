{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convert = exports.encode = exports.decode = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.mimeEncode = mimeEncode;\nexports.mimeDecode = mimeDecode;\nexports.base64Encode = base64Encode;\nexports.base64Decode = base64Decode;\nexports.quotedPrintableEncode = quotedPrintableEncode;\nexports.quotedPrintableDecode = quotedPrintableDecode;\nexports.mimeWordEncode = mimeWordEncode;\nexports.mimeWordsEncode = mimeWordsEncode;\nexports.mimeWordDecode = mimeWordDecode;\nexports.mimeWordsDecode = mimeWordsDecode;\nexports.foldLines = foldLines;\nexports.headerLineEncode = headerLineEncode;\nexports.headerLineDecode = headerLineDecode;\nexports.headerLinesDecode = headerLinesDecode;\nexports.parseHeaderValue = parseHeaderValue;\nexports.continuationEncode = continuationEncode;\n\nvar _emailjsBase = require('emailjs-base64');\n\nvar _charset = require('./charset');\n\nvar _ramda = require('ramda'); // Lines can't be longer than 76 + <CR><LF> = 78 bytes\n// http://tools.ietf.org/html/rfc2045#section-6.7\n\n\nvar MAX_LINE_LENGTH = 76;\nvar MAX_MIME_WORD_LENGTH = 52;\nvar MAX_B64_MIME_WORD_BYTE_LENGTH = 39;\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * @param {String|Uint8Array} data Either a string or an Uint8Array\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Mime encoded string\n */\n\nfunction mimeEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var buffer = (0, _charset.convert)(data, fromCharset);\n  return buffer.reduce(function (aggregate, ord, index) {\n    return _checkRanges(ord) && !((ord === 0x20 || ord === 0x09) && (index === buffer.length - 1 || buffer[index + 1] === 0x0a || buffer[index + 1] === 0x0d)) ? aggregate + String.fromCharCode(ord) // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n    : aggregate + '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }, '');\n\n  function _checkRanges(nr) {\n    var ranges = [// https://tools.ietf.org/html/rfc2045#section-6.7\n    [0x09], // <TAB>\n    [0x0A], // <LF>\n    [0x0D], // <CR>\n    [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n    [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    return ranges.reduce(function (val, range) {\n      return val || range.length === 1 && nr === range[0] || range.length === 2 && nr >= range[0] && nr <= range[1];\n    }, false);\n  }\n}\n/**\n * Decodes mime encoded string to an unicode string\n *\n * @param {String} str Mime encoded string\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Decoded unicode string\n */\n\n\nfunction mimeDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var encodedBytesCount = (str.match(/=[\\da-fA-F]{2}/g) || []).length;\n  var buffer = new Uint8Array(str.length - encodedBytesCount * 2);\n\n  for (var i = 0, len = str.length, bufferPos = 0; i < len; i++) {\n    var hex = str.substr(i + 1, 2);\n    var chr = str.charAt(i);\n\n    if (chr === '=' && hex && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16);\n      i += 2;\n    } else {\n      buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n  }\n\n  return (0, _charset.decode)(buffer, fromCharset);\n}\n/**\n * Encodes a string or an typed array of given charset into unicode\n * base64 string. Also adds line breaks\n *\n * @param {String|Uint8Array} data String or typed array to be base64 encoded\n * @param {String} Initial charset, e.g. 'binary'. Defaults to 'UTF-8'\n * @return {String} Base64 encoded string\n */\n\n\nfunction base64Encode(data) {\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var buf = typeof data !== 'string' && fromCharset === 'binary' ? data : (0, _charset.convert)(data, fromCharset);\n  var b64 = (0, _emailjsBase.encode)(buf);\n  return _addBase64SoftLinebreaks(b64);\n}\n/**\n * Decodes a base64 string of any charset into an unicode string\n *\n * @param {String} str Base64 encoded string\n * @param {String} [fromCharset='UTF-8'] Original charset of the base64 encoded string\n * @return {String} Decoded unicode string\n */\n\n\nfunction base64Decode(str, fromCharset) {\n  var buf = (0, _emailjsBase.decode)(str, _emailjsBase.OUTPUT_TYPED_ARRAY);\n  return fromCharset === 'binary' ? (0, _charset.arr2str)(buf) : (0, _charset.decode)(buf, fromCharset);\n}\n/**\n * Encodes a string or an Uint8Array into a quoted printable encoding\n * This is almost the same as mimeEncode, except line breaks will be changed\n * as well to ensure that the lines are never longer than allowed length\n *\n * @param {String|Uint8Array} data String or an Uint8Array to mime encode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime encoded string\n */\n\n\nfunction quotedPrintableEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var mimeEncodedStr = mimeEncode(data, fromCharset).replace(/\\r?\\n|\\r/g, '\\r\\n') // fix line breaks, ensure <CR><LF>\n  .replace(/[\\t ]+$/gm, function (spaces) {\n    return spaces.replace(/ /g, '=20').replace(/\\t/g, '=09');\n  }); // replace spaces in the end of lines\n\n  return _addQPSoftLinebreaks(mimeEncodedStr); // add soft line breaks to ensure line lengths sjorter than 76 bytes\n}\n/**\n * Decodes a string from a quoted printable encoding. This is almost the\n * same as mimeDecode, except line breaks will be changed as well\n *\n * @param {String} str Mime encoded string to decode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime decoded string\n */\n\n\nfunction quotedPrintableDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var rawString = str.replace(/[\\t ]+$/gm, '') // remove invalid whitespace from the end of lines\n  .replace(/=(?:\\r?\\n|$)/g, ''); // remove soft line breaks\n\n  return mimeDecode(rawString, fromCharset);\n}\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *   https://tools.ietf.org/html/rfc2047\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} Single or several mime words joined together\n */\n\n\nfunction mimeWordEncode(data) {\n  var mimeWordEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Q';\n  var fromCharset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'UTF-8';\n  var parts = [];\n  var str = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n\n  if (mimeWordEncoding === 'Q') {\n    var _str = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n\n    var encodedStr = (0, _ramda.pipe)(mimeEncode, qEncodeForbiddenHeaderChars)(_str);\n    parts = encodedStr.length < MAX_MIME_WORD_LENGTH ? [encodedStr] : _splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH);\n  } else {\n    // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n    var j = 0;\n    var i = 0;\n\n    while (i < str.length) {\n      if ((0, _charset.encode)(str.substring(j, i)).length > MAX_B64_MIME_WORD_BYTE_LENGTH) {\n        // we went one character too far, substring at the char before\n        parts.push(str.substring(j, i - 1));\n        j = i - 1;\n      } else {\n        i++;\n      }\n    } // add the remainder of the string\n\n\n    str.substring(j) && parts.push(str.substring(j));\n    parts = parts.map(_charset.encode).map(_emailjsBase.encode);\n  }\n\n  var prefix = '=?UTF-8?' + mimeWordEncoding + '?';\n  var suffix = '?= ';\n  return parts.map(function (p) {\n    return prefix + p + suffix;\n  }).join('').trim();\n}\n/**\n * Q-Encodes remaining forbidden header chars\n *   https://tools.ietf.org/html/rfc2047#section-5\n */\n\n\nvar qEncodeForbiddenHeaderChars = function qEncodeForbiddenHeaderChars(str) {\n  var qEncode = function qEncode(chr) {\n    return chr === ' ' ? '_' : '=' + (chr.charCodeAt(0) < 0x10 ? '0' : '') + chr.charCodeAt(0).toString(16).toUpperCase();\n  };\n\n  return str.replace(/[^a-z0-9!*+\\-/=]/ig, qEncode);\n};\n/**\n * Finds word sequences with non ascii text and converts these to mime words\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} String with possible mime words\n */\n\n\nfunction mimeWordsEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var mimeWordEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Q';\n  var fromCharset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'UTF-8';\n  var regex = /([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g;\n  return (0, _charset.decode)((0, _charset.convert)(data, fromCharset)).replace(regex, function (match) {\n    return match.length ? mimeWordEncode(match, mimeWordEncoding, fromCharset) : '';\n  });\n}\n/**\n * Decode a complete mime word encoded string\n *\n * @param {String} str Mime word encoded string\n * @return {String} Decoded unicode string\n */\n\n\nfunction mimeWordDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var match = str.match(/^=\\?([\\w_\\-*]+)\\?([QqBb])\\?([^?]*)\\?=$/i);\n  if (!match) return str; // RFC2231 added language tag to the encoding\n  // see: https://tools.ietf.org/html/rfc2231#section-5\n  // this implementation silently ignores this tag\n\n  var fromCharset = match[1].split('*').shift();\n  var encoding = (match[2] || 'Q').toString().toUpperCase();\n  var rawString = (match[3] || '').replace(/_/g, ' ');\n\n  if (encoding === 'B') {\n    return base64Decode(rawString, fromCharset);\n  } else if (encoding === 'Q') {\n    return mimeDecode(rawString, fromCharset);\n  } else {\n    return str;\n  }\n}\n/**\n * Decode a string that might include one or several mime words\n *\n * @param {String} str String including some mime words that will be encoded\n * @return {String} Decoded unicode string\n */\n\n\nfunction mimeWordsDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  str = str.toString().replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, '$1'); // join bytes of multi-byte UTF-8\n\n  var prevEncoding = void 0;\n  str = str.replace(/(\\?=)?=\\?[uU][tT][fF]-8\\?([QqBb])\\?/g, function (match, endOfPrevWord, encoding) {\n    var result = endOfPrevWord && encoding === prevEncoding ? '' : match;\n    prevEncoding = encoding;\n    return result;\n  });\n  str = str.replace(/=\\?[\\w_\\-*]+\\?[QqBb]\\?[^?]*\\?=/g, function (mimeWord) {\n    return mimeWordDecode(mimeWord.replace(/\\s+/g, ''));\n  });\n  return str;\n}\n/**\n * Folds long lines, useful for folding header lines (afterSpace=false) and\n * flowed text (afterSpace=true)\n *\n * @param {String} str String to be folded\n * @param {Boolean} afterSpace If true, leave a space in th end of a line\n * @return {String} String with folded lines\n */\n\n\nfunction foldLines() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var afterSpace = arguments[1];\n  var pos = 0;\n  var len = str.length;\n  var result = '';\n  var line = void 0,\n      match = void 0;\n\n  while (pos < len) {\n    line = str.substr(pos, MAX_LINE_LENGTH);\n\n    if (line.length < MAX_LINE_LENGTH) {\n      result += line;\n      break;\n    }\n\n    if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n      line = match[0];\n      result += line;\n      pos += line.length;\n      continue;\n    } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n      line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n    } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n      line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n    }\n\n    result += line;\n    pos += line.length;\n\n    if (pos < len) {\n      result += '\\r\\n';\n    }\n  }\n\n  return result;\n}\n/**\n * Encodes and folds a header line for a MIME message header.\n * Shorthand for mimeWordsEncode + foldLines\n *\n * @param {String} key Key name, will not be encoded\n * @param {String|Uint8Array} value Value to be encoded\n * @param {String} [fromCharset='UTF-8'] Character set of the value\n * @return {String} encoded and folded header line\n */\n\n\nfunction headerLineEncode(key, value, fromCharset) {\n  var encodedValue = mimeWordsEncode(value, 'Q', fromCharset);\n  return foldLines(key + ': ' + encodedValue);\n}\n/**\n * The result is not mime word decoded, you need to do your own decoding based\n * on the rules for the specific header key\n *\n * @param {String} headerLine Single header line, might include linebreaks as well if folded\n * @return {Object} And object of {key, value}\n */\n\n\nfunction headerLineDecode() {\n  var headerLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var line = headerLine.toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim();\n  var match = line.match(/^\\s*([^:]+):(.*)$/);\n  return {\n    key: (match && match[1] || '').trim(),\n    value: (match && match[2] || '').trim()\n  };\n}\n/**\n * Parses a block of header lines. Does not decode mime words as every\n * header might have its own rules (eg. formatted email addresses and such)\n *\n * @param {String} headers Headers string\n * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n */\n\n\nfunction headerLinesDecode(headers) {\n  var lines = headers.split(/\\r?\\n|\\r/);\n  var headersObj = {};\n\n  for (var i = lines.length - 1; i >= 0; i--) {\n    if (i && lines[i].match(/^\\s/)) {\n      lines[i - 1] += '\\r\\n' + lines[i];\n      lines.splice(i, 1);\n    }\n  }\n\n  for (var _i = 0, len = lines.length; _i < len; _i++) {\n    var header = headerLineDecode(lines[_i]);\n    var key = header.key.toLowerCase();\n    var value = header.value;\n\n    if (!headersObj[key]) {\n      headersObj[key] = value;\n    } else {\n      headersObj[key] = [].concat(headersObj[key], value);\n    }\n  }\n\n  return headersObj;\n}\n/**\n * Parses a header value with key=value arguments into a structured\n * object.\n *\n *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n *   {\n *     'value': 'text/plain',\n *     'params': {\n *       'charset': 'UTF-8'\n *     }\n *   }\n *\n * @param {String} str Header value\n * @return {Object} Header value as a parsed structure\n */\n\n\nfunction parseHeaderValue(str) {\n  var response = {\n    value: false,\n    params: {}\n  };\n  var key = false;\n  var value = '';\n  var type = 'value';\n  var quote = false;\n  var escaped = false;\n  var chr = void 0;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i);\n\n    if (type === 'key') {\n      if (chr === '=') {\n        key = value.trim().toLowerCase();\n        type = 'value';\n        value = '';\n        continue;\n      }\n\n      value += chr;\n    } else {\n      if (escaped) {\n        value += chr;\n      } else if (chr === '\\\\') {\n        escaped = true;\n        continue;\n      } else if (quote && chr === quote) {\n        quote = false;\n      } else if (!quote && chr === '\"') {\n        quote = chr;\n      } else if (!quote && chr === ';') {\n        if (key === false) {\n          response.value = value.trim();\n        } else {\n          response.params[key] = value.trim();\n        }\n\n        type = 'key';\n        value = '';\n      } else {\n        value += chr;\n      }\n\n      escaped = false;\n    }\n  }\n\n  if (type === 'value') {\n    if (key === false) {\n      response.value = value.trim();\n    } else {\n      response.params[key] = value.trim();\n    }\n  } else if (value.trim()) {\n    response.params[value.trim().toLowerCase()] = '';\n  } // handle parameter value continuations\n  // https://tools.ietf.org/html/rfc2231#section-3\n  // preprocess values\n\n\n  Object.keys(response.params).forEach(function (key) {\n    var actualKey, nr, match, value;\n\n    if (match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/)) {\n      actualKey = key.substr(0, match.index);\n      nr = Number(match[2] || match[3]) || 0;\n\n      if (!response.params[actualKey] || _typeof(response.params[actualKey]) !== 'object') {\n        response.params[actualKey] = {\n          charset: false,\n          values: []\n        };\n      }\n\n      value = response.params[key];\n\n      if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n        response.params[actualKey].charset = match[1] || 'iso-8859-1';\n        value = match[2];\n      }\n\n      response.params[actualKey].values[nr] = value; // remove the old reference\n\n      delete response.params[key];\n    }\n  }); // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n\n  Object.keys(response.params).forEach(function (key) {\n    var value;\n\n    if (response.params[key] && Array.isArray(response.params[key].values)) {\n      value = response.params[key].values.map(function (val) {\n        return val || '';\n      }).join('');\n\n      if (response.params[key].charset) {\n        // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n        response.params[key] = '=?' + response.params[key].charset + '?Q?' + value.replace(/[=?_\\s]/g, function (s) {\n          // fix invalidly encoded chars\n          var c = s.charCodeAt(0).toString(16);\n          return s === ' ' ? '_' : '%' + (c.length < 2 ? '0' : '') + c;\n        }).replace(/%/g, '=') + '?='; // change from urlencoding to percent encoding\n      } else {\n        response.params[key] = value;\n      }\n    }\n  });\n  return response;\n}\n/**\n * Encodes a string or an Uint8Array to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n * Useful for splitting long parameter values.\n *\n * For example\n *      title=\"unicode string\"\n * becomes\n *     title*0*=\"utf-8''unicode\"\n *     title*1*=\"%20string\"\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {Number} [maxLength=50] Max length for generated chunks\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {Array} A list of encoded keys and headers\n */\n\n\nfunction continuationEncode(key, data, maxLength, fromCharset) {\n  var list = [];\n  var encodedStr = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n  var line;\n  maxLength = maxLength || 50; // process ascii only text\n\n  if (/^[\\w.\\- ]*$/.test(data)) {\n    // check if conversion is even needed\n    if (encodedStr.length <= maxLength) {\n      return [{\n        key: key,\n        value: /[\\s\";=]/.test(encodedStr) ? '\"' + encodedStr + '\"' : encodedStr\n      }];\n    }\n\n    encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n      list.push({\n        line: str\n      });\n      return '';\n    });\n\n    if (encodedStr) {\n      list.push({\n        line: encodedStr\n      });\n    }\n  } else {\n    // process text with unicode or special chars\n    var uriEncoded = encodeURIComponent('utf-8\\'\\'' + encodedStr);\n    var i = 0;\n\n    while (true) {\n      var len = maxLength; // must not split hex encoded byte between lines\n\n      if (uriEncoded[i + maxLength - 1] === '%') {\n        len -= 1;\n      } else if (uriEncoded[i + maxLength - 2] === '%') {\n        len -= 2;\n      }\n\n      line = uriEncoded.substr(i, len);\n\n      if (!line) {\n        break;\n      }\n\n      list.push({\n        line: line,\n        encoded: true\n      });\n      i += line.length;\n    }\n  }\n\n  return list.map(function (item, i) {\n    return {\n      // encoded lines: {name}*{part}*\n      // unencoded lines: {name}*{part}\n      // if any line needs to be encoded then the first line (part==0) is always encoded\n      key: key + '*' + i + (item.encoded ? '*' : ''),\n      value: /[\\s\";=]/.test(item.line) ? '\"' + item.line + '\"' : item.line\n    };\n  });\n}\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\n\n\nfunction _splitMimeEncodedString(str) {\n  var maxlen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n  var minWordLength = 12; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n\n  var maxWordLength = Math.max(maxlen, minWordLength);\n  var lines = [];\n\n  while (str.length) {\n    var curLine = str.substr(0, maxWordLength);\n    var match = curLine.match(/=[0-9A-F]?$/i); // skip incomplete escaped char\n\n    if (match) {\n      curLine = curLine.substr(0, match.index);\n    }\n\n    var done = false;\n\n    while (!done) {\n      var chr = void 0;\n      done = true;\n\n      var _match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i); // check if not middle of a unicode char sequence\n\n\n      if (_match) {\n        chr = parseInt(_match[1], 16); // invalid sequence, move one char back anc recheck\n\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3);\n          done = false;\n        }\n      }\n    }\n\n    if (curLine.length) {\n      lines.push(curLine);\n    }\n\n    str = str.substr(curLine.length);\n  }\n\n  return lines;\n}\n\nfunction _addBase64SoftLinebreaks() {\n  var base64EncodedStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return base64EncodedStr.trim().replace(new RegExp('.{' + MAX_LINE_LENGTH + '}', 'g'), '$&\\r\\n').trim();\n}\n/**\n * Adds soft line breaks(the ones that will be stripped out when decoding QP)\n *\n * @param {String} qpEncodedStr String in Quoted-Printable encoding\n * @return {String} String with forced line breaks\n */\n\n\nfunction _addQPSoftLinebreaks() {\n  var qpEncodedStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var pos = 0;\n  var len = qpEncodedStr.length;\n  var lineMargin = Math.floor(MAX_LINE_LENGTH / 3);\n  var result = '';\n  var match = void 0,\n      line = void 0; // insert soft linebreaks where needed\n\n  while (pos < len) {\n    line = qpEncodedStr.substr(pos, MAX_LINE_LENGTH);\n\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > MAX_LINE_LENGTH - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else if (line.substr(-1) === '\\r') {\n      line = line.substr(0, line.length - 1);\n    } else {\n      if (line.match(/=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if (match = line.match(/=[\\da-f]{0,1}$/i)) {\n          line = line.substr(0, line.length - match[0].length);\n        } // ensure that utf-8 sequences are not split\n\n\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/=[\\da-f]{2}$/ig))) {\n          var code = parseInt(match[0].substr(1, 2), 16);\n\n          if (code < 128) {\n            break;\n          }\n\n          line = line.substr(0, line.length - 3);\n\n          if (code >= 0xC0) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === MAX_LINE_LENGTH && line.match(/=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === MAX_LINE_LENGTH) {\n        line = line.substr(0, line.length - 1);\n      }\n\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n\n    result += line;\n  }\n\n  return result;\n}\n\nexports.decode = _charset.decode;\nexports.encode = _charset.encode;\nexports.convert = _charset.convert;","map":null,"metadata":{},"sourceType":"script"}