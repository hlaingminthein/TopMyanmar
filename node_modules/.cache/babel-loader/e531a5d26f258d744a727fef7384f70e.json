{"ast":null,"code":"/*\n * SMTP class written using python's (2.7) smtplib.py as a base\n */\nconst _require = require('net'),\n      Socket = _require.Socket;\n\nconst _require2 = require('crypto'),\n      createHmac = _require2.createHmac;\n\nconst _require3 = require('os'),\n      hostname = _require3.hostname;\n\nconst _require4 = require('tls'),\n      connect = _require4.connect,\n      createSecureContext = _require4.createSecureContext,\n      TLSSocket = _require4.TLSSocket;\n\nconst _require5 = require('events'),\n      EventEmitter = _require5.EventEmitter;\n\nconst SMTPResponse = require('./response');\n\nconst SMTPError = require('./error');\n/**\n * @readonly\n * @type {5000}\n */\n\n\nconst TIMEOUT = 5000;\n/**\n * @readonly\n * @type {25}\n */\n\nconst SMTP_PORT = 25;\n/**\n * @readonly\n * @type {465}\n */\n\nconst SMTP_SSL_PORT = 465;\n/**\n * @readonly\n * @type {587}\n */\n\nconst SMTP_TLS_PORT = 587;\n/**\n * @readonly\n * @type {'\\r\\n'}\n */\n\nconst CRLF = '\\r\\n';\n/**\n * @readonly\n * @enum\n */\n\nconst AUTH_METHODS = {\n  PLAIN:\n  /** @type {'PLAIN'} */\n  'PLAIN',\n  CRAM_MD5:\n  /** @type {'CRAM-MD5'} */\n  'CRAM-MD5',\n  LOGIN:\n  /** @type {'LOGIN'} */\n  'LOGIN',\n  XOAUTH2:\n  /** @type {'XOAUTH2'} */\n  'XOAUTH2'\n};\n/**\n * @type {0 | 1}\n */\n\nlet DEBUG = 0;\n/**\n * @param {...string} args the message(s) to log\n * @returns {void}\n */\n\nconst log = (...args) => {\n  if (DEBUG === 1) {\n    args.forEach(d => console.log(d));\n  }\n};\n/**\n * @param {function(...*): void} callback the function to call\n * @param {...*} args the arguments to apply to the function\n * @returns {void}\n */\n\n\nconst caller = (callback, ...args) => {\n  if (typeof callback === 'function') {\n    callback.apply(null, args);\n  }\n};\n\nconst SMTPState = {\n  NOTCONNECTED: 0,\n  CONNECTING: 1,\n  CONNECTED: 2\n};\n\nclass SMTP extends EventEmitter {\n  /**\n   * @typedef {Object} SMTPSocketOptions\n   * @property {string} key\n   * @property {string} ca\n   * @property {string} cert\n   *\n   * @typedef {Object} SMTPOptions\n   * @property {number} [timeout]\n   * @property {string} [user]\n   * @property {string} [password]\n   * @property {string} [domain]\n   * @property {string} [host]\n   * @property {number} [port]\n   * @property {boolean|SMTPSocketOptions} [ssl]\n   * @property {boolean|SMTPSocketOptions} [tls]\n   * @property {string[]} [authentication]\n   *\n   * @constructor\n   * @param {SMTPOptions} [options] instance options\n   */\n  constructor({\n    timeout,\n    host,\n    user,\n    password,\n    domain,\n    port,\n    ssl,\n    tls,\n    authentication\n  } = {}) {\n    super();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._state = SMTPState.NOTCONNECTED;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._secure = false;\n    /**\n     * @type {Socket|TLSSocket}\n     */\n\n    this.sock = null;\n    /**\n     * @type {{ [i: string]: string | boolean }}\n     */\n\n    this.features = null;\n    /**\n     * @type {SMTPResponse.SMTPResponse}\n     */\n\n    this.monitor = null;\n    /**\n     * @type {string[]}\n     */\n\n    this.authentication = Array.isArray(authentication) ? authentication : [AUTH_METHODS.CRAM_MD5, AUTH_METHODS.LOGIN, AUTH_METHODS.PLAIN, AUTH_METHODS.XOAUTH2];\n    /**\n     * @type {number} }\n     */\n\n    this.timeout = typeof timeout === 'number' ? timeout : TIMEOUT;\n    /**\n     * @type {string} }\n     */\n\n    this.domain = typeof domain === 'string' ? domain : hostname();\n    /**\n     * @type {string} }\n     */\n\n    this.host = typeof host === 'string' ? host : 'localhost';\n    /**\n     * @type {boolean|SMTPSocketOptions}\n     */\n\n    this.ssl = ssl != null && (typeof ssl === 'boolean' || typeof ssl === 'object' && Array.isArray(ssl) === false) ? ssl : false;\n    /**\n     * @type {boolean|SMTPSocketOptions}\n     */\n\n    this.tls = tls != null && (typeof tls === 'boolean' || typeof tls === 'object' && Array.isArray(tls) === false) ? tls : false;\n    /**\n     * @type {number}\n     */\n\n    this.port = port || (ssl ? SMTP_SSL_PORT : tls ? SMTP_TLS_PORT : SMTP_PORT);\n    /**\n     * @type {boolean}\n     */\n\n    this.loggedin = user && password ? false : true; // keep these strings hidden when quicky debugging/logging\n\n    this.user =\n    /** @returns {string} */\n    () => user;\n\n    this.password =\n    /** @returns {string} */\n    () => password;\n  }\n  /**\n   * @param {0 | 1} level -\n   * @returns {void}\n   */\n\n\n  debug(level) {\n    DEBUG = level;\n  }\n  /**\n   * @returns {number} the current state\n   */\n\n\n  state() {\n    return this._state;\n  }\n  /**\n   * @returns {boolean} whether or not the instance is authorized\n   */\n\n\n  authorized() {\n    return this.loggedin;\n  }\n  /**\n   * @typedef {Object} ConnectOptions\n   * @property {boolean} [ssl]\n   *\n   * @param {function(...*): void} callback function to call after response\n   * @param {number} [port] the port to use for the connection\n   * @param {string} [host] the hostname to use for the connection\n   * @param {ConnectOptions} [options={}] the options\n   * @returns {void}\n   */\n\n\n  connect(callback, port = this.port, host = this.host, options = {}) {\n    this.port = port;\n    this.host = host;\n    this.ssl = options.ssl || this.ssl;\n\n    if (this._state !== SMTPState.NOTCONNECTED) {\n      this.quit(() => this.connect(callback, port, host, options));\n    }\n    /**\n     * @returns {void}\n     */\n\n\n    const connected = () => {\n      log(\"connected: \".concat(this.host, \":\").concat(this.port));\n\n      if (this.ssl && !this.tls) {\n        // if key/ca/cert was passed in, check if connection is authorized\n        if (typeof this.ssl !== 'boolean' && this.sock instanceof TLSSocket && !this.sock.authorized) {\n          this.close(true);\n          caller(callback, SMTPError('could not establish an ssl connection', SMTPError.CONNECTIONAUTH));\n        } else {\n          this._secure = true;\n        }\n      }\n    };\n    /**\n     * @param {Error} err err\n     * @returns {void}\n     */\n\n\n    const connectedErrBack = err => {\n      if (!err) {\n        connected();\n      } else {\n        this.close(true);\n        caller(callback, SMTPError('could not connect', SMTPError.COULDNOTCONNECT, err));\n      }\n    };\n\n    const response = (err, msg) => {\n      if (err) {\n        if (this._state === SMTPState.NOTCONNECTED && !this.sock) {\n          return;\n        }\n\n        this.close(true);\n        caller(callback, err);\n      } else if (msg.code == '220') {\n        log(msg.data); // might happen first, so no need to wait on connected()\n\n        this._state = SMTPState.CONNECTED;\n        caller(callback, null, msg.data);\n      } else {\n        log(\"response (data): \".concat(msg.data));\n        this.quit(() => {\n          caller(callback, SMTPError('bad response on connection', SMTPError.BADRESPONSE, err, msg.data));\n        });\n      }\n    };\n\n    this._state = SMTPState.CONNECTING;\n    log(\"connecting: \".concat(this.host, \":\").concat(this.port));\n\n    if (this.ssl) {\n      this.sock = connect(this.port, this.host, typeof this.ssl === 'object' ? this.ssl : {}, connected);\n    } else {\n      this.sock = new Socket();\n      this.sock.connect(this.port, this.host, connectedErrBack);\n    }\n\n    this.monitor = SMTPResponse.monitor(this.sock, this.timeout, () => this.close(true));\n    this.sock.once('response', response);\n    this.sock.once('error', response); // the socket could reset or throw, so let's handle it and let the user know\n  }\n  /**\n   * @param {string} str the string to send\n   * @param {*} callback function to call after response\n   * @returns {void}\n   */\n\n\n  send(str, callback) {\n    if (this.sock && this._state === SMTPState.CONNECTED) {\n      log(str);\n      this.sock.once('response', (err, msg) => {\n        if (err) {\n          caller(callback, err);\n        } else {\n          log(msg.data);\n          caller(callback, null, msg);\n        }\n      });\n      this.sock.write(str);\n    } else {\n      this.close(true);\n      caller(callback, SMTPError('no connection has been established', SMTPError.NOCONNECTION));\n    }\n  }\n  /**\n   * @param {string} cmd command to issue\n   * @param {function(...*): void} callback function to call after response\n   * @param {(number[] | number)} [codes=[250]] array codes\n   * @returns {void}\n   */\n\n\n  command(cmd, callback, codes = [250]) {\n    const codesArray = Array.isArray(codes) ? codes : typeof codes === 'number' ? [codes] : [250];\n\n    const response = (err, msg) => {\n      if (err) {\n        caller(callback, err);\n      } else {\n        if (codesArray.indexOf(Number(msg.code)) !== -1) {\n          caller(callback, err, msg.data, msg.message);\n        } else {\n          const suffix = msg.message ? \": \".concat(msg.message) : '';\n          const errorMessage = \"bad response on command '\".concat(cmd.split(' ')[0], \"'\").concat(suffix);\n          caller(callback, SMTPError(errorMessage, SMTPError.BADRESPONSE, null, msg.data));\n        }\n      }\n    };\n\n    this.send(cmd + CRLF, response);\n  }\n  /**\n   * SMTP 'helo' command.\n   *\n   * Hostname to send for self command defaults to the FQDN of the local\n   * host.\n   *\n   * @param {function(...*): void} callback function to call after response\n   * @param {string} domain the domain to associate with the 'helo' request\n   * @returns {void}\n   */\n\n\n  helo(callback, domain) {\n    this.command(\"helo \".concat(domain || this.domain), (err, data) => {\n      if (err) {\n        caller(callback, err);\n      } else {\n        this.parse_smtp_features(data);\n        caller(callback, err, data);\n      }\n    });\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @returns {void}\n   */\n\n\n  starttls(callback) {\n    const response = (err, msg) => {\n      if (err) {\n        err.message += ' while establishing a starttls session';\n        caller(callback, err);\n      } else {\n        const secureContext = createSecureContext(typeof this.tls === 'object' ? this.tls : {});\n        const secureSocket = new TLSSocket(this.sock, {\n          secureContext\n        });\n        secureSocket.on('error', err => {\n          this.close(true);\n          caller(callback, err);\n        });\n        this._secure = true;\n        this.sock = secureSocket;\n        SMTPResponse.monitor(this.sock, this.timeout, () => this.close(true));\n        caller(callback, msg.data);\n      }\n    };\n\n    this.command('starttls', response, [220]);\n  }\n  /**\n   * @param {string} data the string to parse for features\n   * @returns {void}\n   */\n\n\n  parse_smtp_features(data) {\n    //  According to RFC1869 some (badly written)\n    //  MTA's will disconnect on an ehlo. Toss an exception if\n    //  that happens -ddm\n    data.split('\\n').forEach(ext => {\n      const parse = ext.match(/^(?:\\d+[-=]?)\\s*?([^\\s]+)(?:\\s+(.*)\\s*?)?$/); // To be able to communicate with as many SMTP servers as possible,\n      // we have to take the old-style auth advertisement into account,\n      // because:\n      // 1) Else our SMTP feature parser gets confused.\n      // 2) There are some servers that only advertise the auth methods we\n      // support using the old style.\n\n      if (parse != null) {\n        // RFC 1869 requires a space between ehlo keyword and parameters.\n        // It's actually stricter, in that only spaces are allowed between\n        // parameters, but were not going to check for that here.  Note\n        // that the space isn't present if there are no parameters.\n        this.features[parse[1].toLowerCase()] = parse[2] || true;\n      }\n    });\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @param {string} domain the domain to associate with the 'ehlo' request\n   * @returns {void}\n   */\n\n\n  ehlo(callback, domain) {\n    this.features = {};\n    this.command(\"ehlo \".concat(domain || this.domain), (err, data) => {\n      if (err) {\n        caller(callback, err);\n      } else {\n        this.parse_smtp_features(data);\n\n        if (this.tls && !this._secure) {\n          this.starttls(() => this.ehlo(callback, domain));\n        } else {\n          caller(callback, err, data);\n        }\n      }\n    });\n  }\n  /**\n   * @param {string} opt the features keyname to check\n   * @returns {boolean} whether the extension exists\n   */\n\n\n  has_extn(opt) {\n    return this.features[opt.toLowerCase()] === undefined;\n  }\n  /**\n   * SMTP 'help' command, returns text from the server\n   * @param {function(...*): void} callback function to call after response\n   * @param {string} domain the domain to associate with the 'help' request\n   * @returns {void}\n   */\n\n\n  help(callback, domain) {\n    this.command(domain ? \"help \".concat(domain) : 'help', callback, [211, 214]);\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @returns {void}\n   */\n\n\n  rset(callback) {\n    this.command('rset', callback);\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @returns {void}\n   */\n\n\n  noop(callback) {\n    this.send('noop', callback);\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @param {string} from the sender\n   * @returns {void}\n   */\n\n\n  mail(callback, from) {\n    this.command(\"mail FROM:\".concat(from), callback);\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @param {string} to the receiver\n   * @returns {void}\n   */\n\n\n  rcpt(callback, to) {\n    this.command(\"RCPT TO:\".concat(to), callback, [250, 251]);\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @returns {void}\n   */\n\n\n  data(callback) {\n    this.command('data', callback, [354]);\n  }\n  /**\n   * @param {function(...*): void} callback function to call after response\n   * @returns {void}\n   */\n\n\n  data_end(callback) {\n    this.command(\"\".concat(CRLF, \".\"), callback);\n  }\n  /**\n   * @param {string} data the message to send\n   * @returns {void}\n   */\n\n\n  message(data) {\n    log(data);\n    this.sock.write(data);\n  }\n  /**\n   * SMTP 'verify' command -- checks for address validity.\n   *\n   * @param {string} address the address to validate\n   * @param {function(...*): void} callback function to call after response\n   * @returns {void}\n   */\n\n\n  verify(address, callback) {\n    this.command(\"vrfy \".concat(address), callback, [250, 251, 252]);\n  }\n  /**\n   * SMTP 'expn' command -- expands a mailing list.\n   *\n   * @param {string} address the mailing list to expand\n   * @param {function(...*): void} callback function to call after response\n   * @returns {void}\n   */\n\n\n  expn(address, callback) {\n    this.command(\"expn \".concat(address), callback);\n  }\n  /**\n   * Calls this.ehlo() and, if an error occurs, this.helo().\n   *\n   * If there has been no previous EHLO or HELO command self session, self\n   * method tries ESMTP EHLO first.\n   *\n   * @param {function(...*): void} callback function to call after response\n   * @param {string} [domain] the domain to associate with the command\n   * @returns {void}\n   */\n\n\n  ehlo_or_helo_if_needed(callback, domain) {\n    // is this code callable...?\n    if (!this.features) {\n      const response = (err, data) => caller(callback, err, data);\n\n      this.ehlo((err, data) => {\n        if (err) {\n          this.helo(response, domain);\n        } else {\n          caller(callback, err, data);\n        }\n      }, domain);\n    }\n  }\n  /**\n   * Log in on an SMTP server that requires authentication.\n   *\n   * If there has been no previous EHLO or HELO command self session, self\n   * method tries ESMTP EHLO first.\n   *\n   * This method will return normally if the authentication was successful.\n   *\n   * @param {function(...*): void} callback function to call after response\n   * @param {string} [user] the username to authenticate with\n   * @param {string} [password] the password for the authentication\n   * @param {{ method: string, domain: string }} [options] login options\n   * @returns {void}\n   */\n\n\n  login(callback, user, password, options) {\n    const login = {\n      user: user ? () => user : this.user,\n      password: password ? () => password : this.password,\n      method: options && options.method ? options.method.toUpperCase() : ''\n    };\n    const domain = options && options.domain ? options.domain : this.domain;\n\n    const initiate = (err, data) => {\n      if (err) {\n        caller(callback, err);\n        return;\n      }\n\n      let method = null;\n      /**\n       * @param {string} challenge challenge\n       * @returns {string} base64 cram hash\n       */\n\n      const encode_cram_md5 = challenge => {\n        const hmac = createHmac('md5', login.password());\n        hmac.update(Buffer.from(challenge, 'base64').toString('ascii'));\n        return Buffer.from(\"\".concat(login.user(), \" \").concat(hmac.digest('hex'))).toString('base64');\n      };\n      /**\n       * @returns {string} base64 login/password\n       */\n\n\n      const encode_plain = () => Buffer.from(\"\\0\".concat(login.user(), \"\\0\").concat(login.password())).toString('base64');\n      /**\n       * @see https://developers.google.com/gmail/xoauth2_protocol\n       * @returns {string} base64 xoauth2 auth token\n       */\n\n\n      const encode_xoauth2 = () => Buffer.from(\"user=\".concat(login.user(), \"\\x01auth=Bearer \").concat(login.password(), \"\\x01\\x01\")).toString('base64'); // List of authentication methods we support: from preferred to\n      // less preferred methods.\n\n\n      if (!method) {\n        const preferred = this.authentication;\n        let auth = '';\n\n        if (this.features && this.features.auth) {\n          if (typeof this.features.auth === 'string') {\n            auth = this.features.auth;\n          }\n        }\n\n        for (let i = 0; i < preferred.length; i++) {\n          if (auth.includes(preferred[i])) {\n            method = preferred[i];\n            break;\n          }\n        }\n      }\n      /**\n       * handle bad responses from command differently\n       * @param {Error} err err\n       * @param {*} data data\n       * @returns {void}\n       */\n\n\n      const failed = (err, data) => {\n        this.loggedin = false;\n        this.close(); // if auth is bad, close the connection, it won't get better by itself\n\n        caller(callback, SMTPError('authorization.failed', SMTPError.AUTHFAILED, err, data));\n      };\n      /**\n       * @param {Error} err err\n       * @param {*} data data\n       * @returns {void}\n       */\n\n\n      const response = (err, data) => {\n        if (err) {\n          failed(err, data);\n        } else {\n          this.loggedin = true;\n          caller(callback, err, data);\n        }\n      };\n      /**\n       * @param {Error} err err\n       * @param {*} data data\n       * @param {string} msg msg\n       * @returns {void}\n       */\n\n\n      const attempt = (err, data, msg) => {\n        if (err) {\n          failed(err, data);\n        } else {\n          if (method === AUTH_METHODS.CRAM_MD5) {\n            this.command(encode_cram_md5(msg), response, [235, 503]);\n          } else if (method === AUTH_METHODS.LOGIN) {\n            this.command(Buffer.from(login.password()).toString('base64'), response, [235, 503]);\n          }\n        }\n      };\n      /**\n       * @param {Error} err err\n       * @param {*} data data\n       * @param {string} msg msg\n       * @returns {void}\n       */\n\n\n      const attempt_user = (err, data, msg) => {\n        if (err) {\n          failed(err, data);\n        } else {\n          if (method === AUTH_METHODS.LOGIN) {\n            this.command(Buffer.from(login.user()).toString('base64'), attempt, [334]);\n          }\n        }\n      };\n\n      switch (method) {\n        case AUTH_METHODS.CRAM_MD5:\n          this.command(\"AUTH  \".concat(AUTH_METHODS.CRAM_MD5), attempt, [334]);\n          break;\n\n        case AUTH_METHODS.LOGIN:\n          this.command(\"AUTH \".concat(AUTH_METHODS.LOGIN), attempt_user, [334]);\n          break;\n\n        case AUTH_METHODS.PLAIN:\n          this.command(\"AUTH \".concat(AUTH_METHODS.PLAIN, \" \").concat(encode_plain()), response, [235, 503]);\n          break;\n\n        case AUTH_METHODS.XOAUTH2:\n          this.command(\"AUTH \".concat(AUTH_METHODS.XOAUTH2, \" \").concat(encode_xoauth2()), response, [235, 503]);\n          break;\n\n        default:\n          const msg = 'no form of authorization supported';\n          const err = SMTPError(msg, SMTPError.AUTHNOTSUPPORTED, null, data);\n          caller(callback, err);\n          break;\n      }\n    };\n\n    this.ehlo_or_helo_if_needed(initiate, domain);\n  }\n  /**\n   * @param {boolean} [force=false] whether or not to force destroy the connection\n   * @returns {void}\n   */\n\n\n  close(force = false) {\n    if (this.sock) {\n      if (force) {\n        log('smtp connection destroyed!');\n        this.sock.destroy();\n      } else {\n        log('smtp connection closed.');\n        this.sock.end();\n      }\n    }\n\n    if (this.monitor) {\n      this.monitor.stop();\n      this.monitor = null;\n    }\n\n    this._state = SMTPState.NOTCONNECTED;\n    this._secure = false;\n    this.sock = null;\n    this.features = null;\n    this.loggedin = !(this.user() && this.password());\n  }\n  /**\n   * @param {function(...*): void} [callback] function to call after response\n   * @returns {void}\n   */\n\n\n  quit(callback) {\n    this.command('quit', (err, data) => {\n      caller(callback, err, data);\n      this.close();\n    }, [221, 250]);\n  }\n\n}\n\nexports.SMTP = SMTP;\nexports.state = SMTPState;\nexports.authentication = AUTH_METHODS;\nexports.DEFAULT_TIMEOUT = TIMEOUT;","map":null,"metadata":{},"sourceType":"script"}