{"ast":null,"code":"const fs = require('fs');\n\nconst _require = require('os'),\n      hostname = _require.hostname;\n\nconst _require2 = require('stream'),\n      Stream = _require2.Stream;\n\nconst addressparser = require('addressparser');\n\nconst _require3 = require('emailjs-mime-codec'),\n      mimeWordEncode = _require3.mimeWordEncode;\n\nconst _require4 = require('./date'),\n      getRFC2822Date = _require4.getRFC2822Date;\n\nconst CRLF = '\\r\\n';\n/**\n * MIME standard wants 76 char chunks when sending out.\n * @type {76}\n */\n\nconst MIMECHUNK = 76;\n/**\n * meets both base64 and mime divisibility\n * @type {456}\n */\n\nconst MIME64CHUNK =\n/** @type {456} */\nMIMECHUNK * 6;\n/**\n * size of the message stream buffer\n * @type {12768}\n */\n\nconst BUFFERSIZE =\n/** @type {12768} */\nMIMECHUNK * 24 * 7;\n/**\n * @type {number}\n */\n\nlet counter = 0;\n/**\n * @returns {string} the generated boundary\n */\n\nfunction generate_boundary() {\n  let text = '';\n  const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'()+_,-./:=?\";\n\n  for (let i = 0; i < 69; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n\n  return text;\n}\n/**\n * @param {string} l the person to parse into an address\n * @returns {string} the parsed address\n */\n\n\nfunction person2address(l) {\n  return addressparser(l).map(({\n    name,\n    address\n  }) => {\n    return name ? \"\".concat(mimeWordEncode(name).replace(/,/g, '=2C'), \" <\").concat(address, \">\") : address;\n  }).join(', ');\n}\n/**\n * @param {string} header_name the header name to fix\n * @returns {string} the fixed header name\n */\n\n\nfunction fix_header_name_case(header_name) {\n  return header_name.toLowerCase().replace(/^(.)|-(.)/g, match => match.toUpperCase());\n}\n\nclass Message {\n  /**\n   * @typedef {Object} MessageHeaders\n   * @property {string?} content-type\n   * @property {string} [subject]\n   * @property {string} [text]\n   * @property {MessageAttachment} [attachment]\n   * @param {MessageHeaders} headers hash of message headers\n   */\n  constructor(headers) {\n    this.attachments = [];\n    /**\n     * @type {MessageAttachment}\n     */\n\n    this.alternative = null;\n    this.header = {\n      'message-id': \"<\".concat(new Date().getTime(), \".\").concat(counter++, \".\").concat(process.pid, \"@\").concat(hostname(), \">\"),\n      date: getRFC2822Date()\n    };\n    this.content = 'text/plain; charset=utf-8';\n\n    for (const header in headers) {\n      // allow user to override default content-type to override charset or send a single non-text message\n      if (/^content-type$/i.test(header)) {\n        this.content = headers[header];\n      } else if (header === 'text') {\n        this.text = headers[header];\n      } else if (header === 'attachment' && typeof headers[header] === 'object') {\n        const attachment = headers[header];\n\n        if (Array.isArray(attachment)) {\n          for (let i = 0; i < attachment.length; i++) {\n            this.attach(attachment[i]);\n          }\n        } else {\n          this.attach(attachment);\n        }\n      } else if (header === 'subject') {\n        this.header.subject = mimeWordEncode(headers.subject);\n      } else if (/^(cc|bcc|to|from)/i.test(header)) {\n        this.header[header.toLowerCase()] = person2address(headers[header]);\n      } else {\n        // allow any headers the user wants to set??\n        // if(/cc|bcc|to|from|reply-to|sender|subject|date|message-id/i.test(header))\n        this.header[header.toLowerCase()] = headers[header];\n      }\n    }\n  }\n  /**\n   * @param {MessageAttachment} options attachment options\n   * @returns {Message} the current instance for chaining\n   */\n\n\n  attach(options) {\n    /*\n    \tlegacy support, will remove eventually...\n    \targuments -> (path, type, name, headers)\n    */\n    if (typeof options === 'string' && arguments.length > 1) {\n      options = {\n        path: options,\n        type: arguments[1],\n        name: arguments[2]\n      };\n    } // sender can specify an attachment as an alternative\n\n\n    if (options.alternative) {\n      this.alternative = options;\n      this.alternative.charset = options.charset || 'utf-8';\n      this.alternative.type = options.type || 'text/html';\n      this.alternative.inline = true;\n    } else {\n      this.attachments.push(options);\n    }\n\n    return this;\n  }\n  /**\n   * legacy support, will remove eventually...\n   * should use Message.attach() instead\n   * @param {string} html html data\n   * @param {string} [charset='utf-8'] the charset to encode as\n   * @returns {Message} the current Message instance\n   */\n\n\n  attach_alternative(html, charset) {\n    this.alternative = {\n      data: html,\n      charset: charset || 'utf-8',\n      type: 'text/html',\n      inline: true\n    };\n    return this;\n  }\n  /**\n   * @param {function(boolean, string): void} callback This callback is displayed as part of the Requester class.\n   * @returns {void}\n   */\n\n\n  valid(callback) {\n    if (!this.header.from) {\n      callback(false, 'message does not have a valid sender');\n    }\n\n    if (!(this.header.to || this.header.cc || this.header.bcc)) {\n      callback(false, 'message does not have a valid recipient');\n    } else if (this.attachments.length === 0) {\n      callback(true, undefined);\n    } else {\n      const failed = [];\n      this.attachments.forEach(attachment => {\n        if (attachment.path) {\n          if (fs.existsSync(attachment.path) == false) {\n            failed.push(\"\".concat(attachment.path, \" does not exist\"));\n          }\n        } else if (attachment.stream) {\n          if (!attachment.stream.readable) {\n            failed.push('attachment stream is not readable');\n          }\n        } else if (!attachment.data) {\n          failed.push('attachment has no data associated with it');\n        }\n      });\n      callback(failed.length === 0, failed.join(', '));\n    }\n  }\n  /**\n   * returns a stream of the current message\n   * @returns {MessageStream} a stream of the current message\n   */\n\n\n  stream() {\n    return new MessageStream(this);\n  }\n  /**\n   * @param {function(Error, string): void} callback the function to call with the error and buffer\n   * @returns {void}\n   */\n\n\n  read(callback) {\n    let buffer = '';\n    const str = this.stream();\n    str.on('data', data => buffer += data);\n    str.on('end', err => callback(err, buffer));\n    str.on('error', err => callback(err, buffer));\n  }\n\n}\n/**\n * @typedef {Object} MessageAttachmentHeaders\n * @property {string} content-type\n * @property {string} content-transfer-encoding\n * @property {string} content-disposition\n */\n\n/**\n * @typedef {Object} MessageAttachment\n * @property {string} [name]\n * @property {string} [type]\n * @property {string} [charset]\n * @property {string} [method]\n * @property {string} [path]\n * @property {NodeJS.ReadWriteStream} [stream]\n * @property {boolean} [inline]\n * @property {MessageAttachment} [alternative]\n * @property {MessageAttachment[]} [related]\n * @property {*} [encoded]\n * @property {*} [data]\n * @property {MessageAttachmentHeaders} [headers]\n */\n\n\nclass MessageStream extends Stream {\n  /**\n   * @param {Message} message the message to stream\n   */\n  constructor(message) {\n    super();\n    /**\n     * @type {Message}\n     */\n\n    this.message = message;\n    /**\n     * @type {boolean}\n     */\n\n    this.readable = true;\n    /**\n     * @type {boolean}\n     */\n\n    this.paused = false;\n    /**\n     * @type {Buffer}\n     */\n\n    this.buffer = Buffer.alloc(MIMECHUNK * 24 * 7);\n    /**\n     * @type {number}\n     */\n\n    this.bufferIndex = 0;\n    /**\n     * @returns {void}\n     */\n\n    const output_mixed = () => {\n      const boundary = generate_boundary();\n      output(\"Content-Type: multipart/mixed; boundary=\\\"\".concat(boundary, \"\\\"\").concat(CRLF).concat(CRLF, \"--\").concat(boundary).concat(CRLF));\n\n      if (this.message.alternative == null) {\n        output_text(this.message);\n        output_message(boundary, this.message.attachments, 0, close);\n      } else {\n        const cb = () => output_message(boundary, this.message.attachments, 0, close);\n\n        output_alternative(this.message, cb);\n      }\n    };\n    /**\n     * @param {string} boundary the boundary text between outputs\n     * @param {MessageAttachment[]} list the list of potential messages to output\n     * @param {number} index the index of the list item to output\n     * @param {function(): void} callback the function to call if index is greater than upper bound\n     * @returns {void}\n     */\n\n\n    const output_message = (boundary, list, index, callback) => {\n      if (index < list.length) {\n        output(\"--\".concat(boundary).concat(CRLF));\n\n        if (list[index].related) {\n          output_related(list[index], () => output_message(boundary, list, index + 1, callback));\n        } else {\n          output_attachment(list[index], () => output_message(boundary, list, index + 1, callback));\n        }\n      } else {\n        output(\"\".concat(CRLF, \"--\").concat(boundary, \"--\").concat(CRLF).concat(CRLF));\n        callback();\n      }\n    };\n    /**\n     * @param {MessageAttachment} attachment the metadata to use as headers\n     * @returns {void}\n     */\n\n\n    const output_attachment_headers = attachment => {\n      let data = [];\n      const headers = {\n        'content-type': attachment.type + (attachment.charset ? \"; charset=\".concat(attachment.charset) : '') + (attachment.method ? \"; method=\".concat(attachment.method) : ''),\n        'content-transfer-encoding': 'base64',\n        'content-disposition': attachment.inline ? 'inline' : \"attachment; filename=\\\"\".concat(mimeWordEncode(attachment.name), \"\\\"\")\n      }; // allow sender to override default headers\n\n      for (const header in attachment.headers || {}) {\n        headers[header.toLowerCase()] = attachment.headers[header];\n      }\n\n      for (const header in headers) {\n        data = data.concat([fix_header_name_case(header), ': ', headers[header], CRLF]);\n      }\n\n      output(data.concat([CRLF]).join(''));\n    };\n    /**\n     * @param {MessageAttachment} attachment the metadata to use as headers\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    const output_attachment = (attachment, callback) => {\n      const build = attachment.path ? output_file : attachment.stream ? output_stream : output_data;\n      output_attachment_headers(attachment);\n      build(attachment, callback);\n    };\n    /**\n     * @param {MessageAttachment} attachment the metadata to use as headers\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    const output_data = (attachment, callback) => {\n      output_base64(attachment.encoded ? attachment.data : Buffer.from(attachment.data).toString('base64'), callback);\n    };\n    /**\n     * @param {MessageAttachment} attachment the metadata to use as headers\n     * @param {function(NodeJS.ErrnoException): void} next the function to call when the file is closed\n     * @returns {void}\n     */\n\n\n    const output_file = (attachment, next) => {\n      const chunk = MIME64CHUNK * 16;\n      const buffer = Buffer.alloc(chunk);\n\n      const closed = fd => fs.closeSync(fd);\n      /**\n       * @param {Error} err the error to emit\n       * @param {number} fd the file descriptor\n       * @returns {void}\n       */\n\n\n      const opened = (err, fd) => {\n        if (!err) {\n          const read = (err, bytes) => {\n            if (!err && this.readable) {\n              let encoding = attachment && attachment.headers ? attachment.headers['content-transfer-encoding'] || 'base64' : 'base64';\n\n              if (encoding === 'ascii' || encoding === '7bit') {\n                encoding = 'ascii';\n              } else if (encoding === 'binary' || encoding === '8bit') {\n                encoding = 'binary';\n              } else {\n                encoding = 'base64';\n              } // guaranteed to be encoded without padding unless it is our last read\n\n\n              output_base64(buffer.toString(encoding, 0, bytes), () => {\n                if (bytes == chunk) {\n                  // we read a full chunk, there might be more\n                  fs.read(fd, buffer, 0, chunk, null, read);\n                } // that was the last chunk, we are done reading the file\n                else {\n                    this.removeListener('error', closed);\n                    fs.close(fd, next);\n                  }\n              });\n            } else {\n              this.emit('error', err || {\n                message: 'message stream was interrupted somehow!'\n              });\n            }\n          };\n\n          fs.read(fd, buffer, 0, chunk, null, read);\n          this.once('error', closed);\n        } else {\n          this.emit('error', err);\n        }\n      };\n\n      fs.open(attachment.path, 'r', opened);\n    };\n    /**\n     * @param {MessageAttachment} attachment the metadata to use as headers\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    const output_stream = (attachment, callback) => {\n      if (attachment.stream.readable) {\n        let previous = Buffer.alloc(0);\n        attachment.stream.resume();\n        attachment.stream.on('end', () => {\n          output_base64(previous.toString('base64'), callback);\n          this.removeListener('pause', attachment.stream.pause);\n          this.removeListener('resume', attachment.stream.resume);\n          this.removeListener('error', attachment.stream.resume);\n        });\n        attachment.stream.on('data', buff => {\n          // do we have bytes from a previous stream data event?\n          let buffer = Buffer.isBuffer(buff) ? buff : Buffer.from(buff);\n\n          if (previous.byteLength > 0) {\n            buffer = Buffer.concat([previous, buffer]);\n          }\n\n          const padded = buffer.length % MIME64CHUNK;\n          previous = Buffer.alloc(padded); // encode as much of the buffer to base64 without empty bytes\n\n          if (padded > 0) {\n            // copy dangling bytes into previous buffer\n            buffer.copy(previous, 0, buffer.length - padded);\n          }\n\n          output_base64(buffer.toString('base64', 0, buffer.length - padded));\n        });\n        this.on('pause', attachment.stream.pause);\n        this.on('resume', attachment.stream.resume);\n        this.on('error', attachment.stream.resume);\n      } else {\n        this.emit('error', {\n          message: 'stream not readable'\n        });\n      }\n    };\n    /**\n     * @param {string} data the data to output as base64\n     * @param {function(): void} [callback] the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    const output_base64 = (data, callback) => {\n      const loops = Math.ceil(data.length / MIMECHUNK);\n      let loop = 0;\n\n      while (loop < loops) {\n        output(data.substring(MIMECHUNK * loop, MIMECHUNK * (loop + 1)) + CRLF);\n        loop++;\n      }\n\n      if (callback) {\n        callback();\n      }\n    };\n    /**\n     * @param {Message} message the message to output\n     * @returns {void}\n     */\n\n\n    const output_text = message => {\n      let data = [];\n      data = data.concat(['Content-Type:', message.content, CRLF, 'Content-Transfer-Encoding: 7bit', CRLF]);\n      data = data.concat(['Content-Disposition: inline', CRLF, CRLF]);\n      data = data.concat([message.text || '', CRLF, CRLF]);\n      output(data.join(''));\n    };\n    /**\n     * @param {Message} message the message to output\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    const output_alternative = (message, callback) => {\n      const boundary = generate_boundary();\n      output(\"Content-Type: multipart/alternative; boundary=\\\"\".concat(boundary, \"\\\"\").concat(CRLF).concat(CRLF, \"--\").concat(boundary).concat(CRLF));\n      output_text(message);\n      output(\"--\".concat(boundary).concat(CRLF));\n      /**\n       * @returns {void}\n       */\n\n      const finish = () => {\n        output([CRLF, '--', boundary, '--', CRLF, CRLF].join(''));\n        callback();\n      };\n\n      if (message.alternative.related) {\n        output_related(message.alternative, finish);\n      } else {\n        output_attachment(message.alternative, finish);\n      }\n    };\n    /**\n     * @param {MessageAttachment} message the message to output\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    const output_related = (message, callback) => {\n      const boundary = generate_boundary();\n      output(\"Content-Type: multipart/related; boundary=\\\"\".concat(boundary, \"\\\"\").concat(CRLF).concat(CRLF, \"--\").concat(boundary).concat(CRLF));\n      output_attachment(message, () => {\n        output_message(boundary, message.related, 0, () => {\n          output(\"\".concat(CRLF, \"--\").concat(boundary, \"--\").concat(CRLF).concat(CRLF));\n          callback();\n        });\n      });\n    };\n    /**\n     * @returns {void}\n     */\n\n\n    const output_header_data = () => {\n      if (this.message.attachments.length || this.message.alternative) {\n        output(\"MIME-Version: 1.0\".concat(CRLF));\n        output_mixed();\n      } // you only have a text message!\n      else {\n          output_text(this.message);\n          close();\n        }\n    };\n    /**\n     * @returns {void}\n     */\n\n\n    const output_header = () => {\n      let data = [];\n\n      for (const header in this.message.header) {\n        // do not output BCC in the headers (regex) nor custom Object.prototype functions...\n        if (!/bcc/i.test(header) && this.message.header.hasOwnProperty(header)) {\n          data = data.concat([fix_header_name_case(header), ': ', this.message.header[header], CRLF]);\n        }\n      }\n\n      output(data.join(''));\n      output_header_data();\n    };\n    /**\n     * @param {string} data the data to output\n     * @param {function(...args): void} [callback] the function\n     * @param {*[]} [args] array of arguments to pass to the callback\n     * @returns {void}\n     */\n\n\n    const output = (data, callback, args) => {\n      const bytes = Buffer.byteLength(data); // can we buffer the data?\n\n      if (bytes + this.bufferIndex < this.buffer.length) {\n        this.buffer.write(data, this.bufferIndex);\n        this.bufferIndex += bytes;\n\n        if (callback) {\n          callback.apply(null, args);\n        }\n      } // we can't buffer the data, so ship it out!\n      else if (bytes > this.buffer.length) {\n          if (this.bufferIndex) {\n            this.emit('data', this.buffer.toString('utf-8', 0, this.bufferIndex));\n            this.bufferIndex = 0;\n          }\n\n          const loops = Math.ceil(data.length / this.buffer.length);\n          let loop = 0;\n\n          while (loop < loops) {\n            this.emit('data', data.substring(this.buffer.length * loop, this.buffer.length * (loop + 1)));\n            loop++;\n          }\n        } // we need to clean out the buffer, it is getting full\n        else {\n            if (!this.paused) {\n              this.emit('data', this.buffer.toString('utf-8', 0, this.bufferIndex));\n              this.buffer.write(data, 0);\n              this.bufferIndex = bytes; // we could get paused after emitting data...\n\n              if (this.paused) {\n                this.once('resume', () => callback.apply(null, args));\n              } else if (callback) {\n                callback.apply(null, args);\n              }\n            } // we can't empty out the buffer, so let's wait till we resume before adding to it\n            else {\n                this.once('resume', () => output(data, callback, args));\n              }\n          }\n    };\n    /**\n     * @param {*} [err] the error to emit\n     * @returns {void}\n     */\n\n\n    const close = err => {\n      if (err) {\n        this.emit('error', err);\n      } else {\n        this.emit('data', this.buffer.toString('utf-8', 0, this.bufferIndex));\n        this.emit('end');\n      }\n\n      this.buffer = null;\n      this.bufferIndex = 0;\n      this.readable = false;\n      this.removeAllListeners('resume');\n      this.removeAllListeners('pause');\n      this.removeAllListeners('error');\n      this.removeAllListeners('data');\n      this.removeAllListeners('end');\n    };\n\n    this.once('destroy', close);\n    process.nextTick(output_header);\n  }\n  /**\n   * pause the stream\n   * @returns {void}\n   */\n\n\n  pause() {\n    this.paused = true;\n    this.emit('pause');\n  }\n  /**\n   * resume the stream\n   * @returns {void}\n   */\n\n\n  resume() {\n    this.paused = false;\n    this.emit('resume');\n  }\n  /**\n   * destroy the stream\n   * @returns {void}\n   */\n\n\n  destroy() {\n    this.emit('destroy', this.bufferIndex > 0 ? {\n      message: 'message stream destroyed'\n    } : null);\n  }\n  /**\n   * destroy the stream at first opportunity\n   * @returns {void}\n   */\n\n\n  destroySoon() {\n    this.emit('destroy');\n  }\n\n}\n\nexports.Message = Message;\nexports.BUFFERSIZE = BUFFERSIZE;\n\nexports.create = headers => new Message(headers);","map":null,"metadata":{},"sourceType":"script"}