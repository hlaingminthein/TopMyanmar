{"ast":null,"code":"const _require = require('./smtp'),\n      SMTP = _require.SMTP,\n      state = _require.state;\n\nconst _require2 = require('./message'),\n      Message = _require2.Message,\n      create = _require2.create;\n\nconst addressparser = require('addressparser');\n\nclass Client {\n  /**\n   * @typedef {Object} SMTPOptions\n   * @property {number} [timeout]\n   * @property {string} [user]\n   * @property {string} [password]\n   * @property {string} [domain]\n   * @property {string} [host]\n   * @property {number} [port]\n   * @property {boolean} [ssl]\n   * @property {boolean} [tls]\n   * @property {string[]} [authentication]\n   *\n   * @typedef {Object} MessageStack\n   * @property {function(Error, Message): void} [callback]\n   * @property {Message} [message]\n   * @property {string} [returnPath]\n   * @property {string} [from]\n   * @property {string} [subject]\n   * @property {string|Array} [to]\n   * @property {Array} [cc]\n   * @property {Array} [bcc]\n   * @property {string} [text]\n   * @property {*} [attachment]\n   *\n   * @constructor\n   * @param {SMTPOptions} server smtp options\n   */\n  constructor(server) {\n    this.smtp = new SMTP(server); //this.smtp.debug(1);\n\n    /**\n     * @type {MessageStack[]}\n     */\n\n    this.queue = [];\n    /**\n     * @type {NodeJS.Timer}\n     */\n\n    this.timer = null;\n    /**\n     * @type {boolean}\n     */\n\n    this.sending = false;\n    /**\n     * @type {boolean}\n     */\n\n    this.ready = false;\n  }\n  /**\n   * @param {Message|MessageStack} msg msg\n   * @param {function(Error, MessageStack): void} callback callback\n   * @returns {void}\n   */\n\n\n  send(msg, callback) {\n    /**\n     * @type {Message}\n     */\n    const message = msg instanceof Message ? msg : this._canMakeMessage(msg) ? create(msg) : null;\n\n    if (message == null) {\n      callback(new Error('message is not a valid Message instance'),\n      /** @type {MessageStack} */\n      msg);\n      return;\n    }\n\n    message.valid((valid, why) => {\n      if (valid) {\n        const stack = {\n          message,\n          to: addressparser(message.header.to),\n          from: addressparser(message.header.from)[0].address,\n          callback: (callback || function () {}).bind(this)\n        };\n\n        if (message.header.cc) {\n          stack.to = stack.to.concat(addressparser(message.header.cc));\n        }\n\n        if (message.header.bcc) {\n          stack.to = stack.to.concat(addressparser(message.header.bcc));\n        }\n\n        if (message.header['return-path'] && addressparser(message.header['return-path']).length) {\n          stack.returnPath = addressparser(message.header['return-path'])[0].address;\n        }\n\n        this.queue.push(stack);\n\n        this._poll();\n      } else {\n        callback(new Error(why),\n        /** @type {MessageStack} */\n        msg);\n      }\n    });\n  }\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  _poll() {\n    clearTimeout(this.timer);\n\n    if (this.queue.length) {\n      if (this.smtp.state() == state.NOTCONNECTED) {\n        this._connect(this.queue[0]);\n      } else if (this.smtp.state() == state.CONNECTED && !this.sending && this.ready) {\n        this._sendmail(this.queue.shift());\n      }\n    } // wait around 1 seconds in case something does come in,\n    // otherwise close out SMTP connection if still open\n    else if (this.smtp.state() == state.CONNECTED) {\n        this.timer = setTimeout(() => this.smtp.quit(), 1000);\n      }\n  }\n  /**\n   * @private\n   * @param {MessageStack} stack stack\n   * @returns {void}\n   */\n\n\n  _connect(stack) {\n    /**\n     * @param {Error} err callback error\n     * @returns {void}\n     */\n    const connect = err => {\n      if (!err) {\n        const begin = err => {\n          if (!err) {\n            this.ready = true;\n\n            this._poll();\n          } else {\n            stack.callback(err, stack.message); // clear out the queue so all callbacks can be called with the same error message\n\n            this.queue.shift();\n\n            this._poll();\n          }\n        };\n\n        if (!this.smtp.authorized()) {\n          this.smtp.login(begin);\n        } else {\n          this.smtp.ehlo_or_helo_if_needed(begin);\n        }\n      } else {\n        stack.callback(err, stack.message); // clear out the queue so all callbacks can be called with the same error message\n\n        this.queue.shift();\n\n        this._poll();\n      }\n    };\n\n    this.ready = false;\n    this.smtp.connect(connect);\n  }\n  /**\n   * @private\n   * @param {MessageStack} msg message stack\n   * @returns {boolean} can make message\n   */\n\n\n  _canMakeMessage(msg) {\n    return msg.from && (msg.to || msg.cc || msg.bcc) && (msg.text !== undefined || this._containsInlinedHtml(msg.attachment));\n  }\n  /**\n   * @private\n   * @param {*} attachment attachment\n   * @returns {boolean} does contain\n   */\n\n\n  _containsInlinedHtml(attachment) {\n    if (Array.isArray(attachment)) {\n      return attachment.some(att => {\n        return this._isAttachmentInlinedHtml(att);\n      });\n    } else {\n      return this._isAttachmentInlinedHtml(attachment);\n    }\n  }\n  /**\n   * @private\n   * @param {*} attachment attachment\n   * @returns {boolean} is inlined\n   */\n\n\n  _isAttachmentInlinedHtml(attachment) {\n    return attachment && (attachment.data || attachment.path) && attachment.alternative === true;\n  }\n  /**\n   * @private\n   * @param {MessageStack} stack stack\n   * @param {function(MessageStack): void} next next\n   * @returns {function(Error): void} callback\n   */\n\n\n  _sendsmtp(stack, next) {\n    /**\n     * @param {Error} [err] error\n     * @returns {void}\n     */\n    return err => {\n      if (!err && next) {\n        next.apply(this, [stack]);\n      } else {\n        // if we snag on SMTP commands, call done, passing the error\n        // but first reset SMTP state so queue can continue polling\n        this.smtp.rset(() => this._senddone(err, stack));\n      }\n    };\n  }\n  /**\n   * @private\n   * @param {MessageStack} stack stack\n   * @returns {void}\n   */\n\n\n  _sendmail(stack) {\n    const from = stack.returnPath || stack.from;\n    this.sending = true;\n    this.smtp.mail(this._sendsmtp(stack, this._sendrcpt), '<' + from + '>');\n  }\n  /**\n   * @private\n   * @param {MessageStack} stack stack\n   * @returns {void}\n   */\n\n\n  _sendrcpt(stack) {\n    if (stack.to == null || typeof stack.to === 'string') {\n      throw new TypeError('stack.to must be array');\n    }\n\n    const to = stack.to.shift().address;\n    this.smtp.rcpt(this._sendsmtp(stack, stack.to.length ? this._sendrcpt : this._senddata), \"<\".concat(to, \">\"));\n  }\n  /**\n   * @private\n   * @param {MessageStack} stack stack\n   * @returns {void}\n   */\n\n\n  _senddata(stack) {\n    this.smtp.data(this._sendsmtp(stack, this._sendmessage));\n  }\n  /**\n   * @private\n   * @param {MessageStack} stack stack\n   * @returns {void}\n   */\n\n\n  _sendmessage(stack) {\n    const stream = stack.message.stream();\n    stream.on('data', data => this.smtp.message(data));\n    stream.on('end', () => {\n      this.smtp.data_end(this._sendsmtp(stack, () => this._senddone(null, stack)));\n    }); // there is no way to cancel a message while in the DATA portion,\n    // so we have to close the socket to prevent a bad email from going out\n\n    stream.on('error', err => {\n      this.smtp.close();\n\n      this._senddone(err, stack);\n    });\n  }\n  /**\n   * @private\n   * @param {Error} err err\n   * @param {MessageStack} stack stack\n   * @returns {void}\n   */\n\n\n  _senddone(err, stack) {\n    this.sending = false;\n    stack.callback(err, stack.message);\n\n    this._poll();\n  }\n\n}\n\nexports.Client = Client;\n/**\n * @param {SMTPOptions} server smtp options\n * @returns {Client} the client\n */\n\nexports.connect = server => new Client(server);","map":null,"metadata":{},"sourceType":"script"}